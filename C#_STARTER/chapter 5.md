### 5.1 인덱서

인덱서(indexer)
- 배열과 프로퍼티의 특징을 모두 가지는 객체
- 배열을 캡슐화하여 외부의 접근을 제한적으로 허용하는 특별한 도구
- 이를 통해 클래스를 배열처럼 사용할 수 있게 해줌

인덱스가 프로퍼티와 구별되는 점 3가지
1. 인덱서를 정의할 때는 변수명을 사용하지 않고 'this' 키워드를 사용한다.
2. 프로퍼티가 매개변수를 사용하지 않는 것과 달리, 인덱서는 배열을 위한 매개변수를 사용한다.
3. 인덱서는 자동 구현 프로퍼티를 지원하지 않는다.

인덱스 vs 인덱서
인덱스(index) : 배열에서 데이터가 저장되는 위치(주소)를 가리키는 변수
인덱서(index
er) : 특별한 종류의 프로퍼티를 부르는 이름

### 5.2 열거형 클래스

열거형 클래스(enum class)
- 상수의 집합
- 여러 개의 상수를 다루는 만큼 개념적으로는 배열과 유사
- 배열과 달리 열거형 클래스는 상수, 즉 변하지 않는 값이라는 점이 중요
- 프로그램이 실행하는 동안 값을 배정받거나 수정해야 하는 경우에는 배열을 사용하고, 프로그램이 종료될 때까지 값의 변화가 일어나지 않아야 한다면 열거형 클래스를 사용
- ex) enum <열거형 이름> { 값1, 값2, 값3, ... }

### 5.3 정적 선언

정적 선언
정적 : 프로그램이 해당 객체를 처음 호출하는 순간 메모리 공간을 할당받아 프로그램이 끝날 때까지 그 상태를 유지
동적 : 그것이 사용될 때마다 메모리의 공간을 할당받고 또 역할이 끝나면 곧바로 사용하던 메모리를 시스템에 반환

클래스명 <인스턴스명> = new 클래스명();
static으로 선언된 객체들은 인스턴스의 생성없이 바로 사용해야 함
-> 정적으로 선언된 객체들은 메모리에 상주하기 때문에, 사용할 때마다 새로 인스턴스를 생성하지 않고 메모리에서 바로 호출하기 때문
-> 즉, 새로운 인스턴스를 만드는 것이 오히려 오류의 원인이 됨

모든 프로그램의 출발점이 되는 Main() 함수 역시 static으로 선언되어야 하는데, 그 이유 역시 메모리에 상주시키기 위함임

정적 선언 시에 기억해야 하는 4가지
1. 정적으로 선언한 클래스는 인스턴스를 생성할 수 없다. 따라서 <클래스명.객체>의 형태로만 사용할 수 있다.
2. 정적으로 선언한 클래스는 오직 정적 객체만 가질 수 있다.
3. 클래스뿐만 아니라 변수, 함수, 프로퍼티, 생성자도 정적으로 선언할 수 있다.
4. 정적으로 선언한 객체는 정적으로 선언한 객체에서만 호출할 수 있다.

동적 선언
- 정적 선언의 반대말이 동적 선언이다. 동적 선언은 정적 선언과 달리 필요에 따라 메모리를 할당받고 그 역할이 끝나면 사용한 메모리를 반환하게 됨
- 동적 선언에 의해 만들어지는 객체는 값을 계속 유지하지 않음
- static 키워드로 선언하지 않은 모든 객체는 기본적으로 동적으로 간주

동적으로 선언된 클래스가 정적 변수나 정적 함수를 가질 수 있을까? 가능하다!
동적으로 선언된 객체를 정적으로 선언된 객체에서 호출하는 것도 얼마든지 가능하다.
-> 불가능한 것은 오직 정적 객체를 동적 객체에서 호출하는 경우뿐이다.

상수는 그 자체로도 항상 정적 객체에 속한다.
-> static 키워드를 사용하지 않더라도 다른 정적 변수처럼 사용할 수 있다.


C#에서는 클래스 전체를 정적으로 선언할 수도 있다. 단, 정적으로 클래스를 선언할 경우 클래스 안에 들어있는 모든 객체 역시 정적으로 선언해야 한다.
정적으로 선언한 객체가 메모리에 머물러 있기 때문에 나타나는 중요한 특징 중 하나는, 정적 객체를 여러 곳에서 호출하는 경우에 그 값이 공유된다는 사실이다.

### 5.4 상속

상속
- 이미 존재하는 다른 클래스를 기반으로 새로운 클래스를 정의할 수 있게 한다.
- 불필요한 코드의 중복을 피할 수 있고, 프로그램의 유지 및 보수의 편의성과 정확성을 높여준다.
- 하나의 클래스 A를 기반으로 새로운 클래스 B를 정의할 때, A를 부모 클래스라고 부르고 B를 자식 클래스라고 부른다.
- 
